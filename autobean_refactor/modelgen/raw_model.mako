<%
import collections
import stringcase
from autobean_refactor.modelgen.field_descriptor import FieldCardinality
from autobean_refactor.meta_models.base import Floating

typing_imports = {'TypeVar', 'Type', 'final'}
if any(field.cardinality == FieldCardinality.OPTIONAL for field in fields):
    typing_imports.add('Optional')
model_imports = collections.defaultdict(set)
model_imports['punctuation'].add('Whitespace')
for field in fields:
    if field.define_as: continue
    for rule in field.rules:
        name = field.model_name(rule)
        model_imports[stringcase.snakecase(name)].add(name)
%>\
# DO NOT EDIT
# This file is automatically generated by autobean_refactor.modelgen.

from typing import ${', '.join(sorted(typing_imports))}
from .. import base
from .. import internal
% for name, imports in sorted(model_imports.items()):
from ..${name} import ${', '.join(sorted(imports))}
% endfor

% for field in fields:
% if field.type_alias is not None:
${field.type_alias} = ${field.inner_type_original}
% endif
% endfor
_Self = TypeVar('_Self', bound='${model_name}')
% for field in fields:
% if field.define_as:


class ${field.define_as}(internal.SimpleDefaultRawTokenModel):
    RULE = '${next(iter(field.rules))}'
    DEFAULT = '${field.define_default}'
% endif
% endfor


class ${model_name}(base.RawTreeModel):
    RULE = '${model_name.lower()}'

% for field in fields:
% if field.cardinality == FieldCardinality.REQUIRED:
    _${field.name} = internal.required_field[${field.inner_type}]()
% elif field.cardinality == FieldCardinality.OPTIONAL:
    _${field.name} = internal.optional_field[${field.inner_type}](floating=internal.Floating.${field.floating.name}, separators=(Whitespace.from_default(),))
% else:
<% assert False %>\
% endif
% endfor

% for field in fields:
<% if not field.is_public: continue %>\
% if field.cardinality == FieldCardinality.REQUIRED:
    raw_${field.name} = internal.required_node_property(_${field.name})
% elif field.cardinality == FieldCardinality.OPTIONAL:
    raw_${field.name} = internal.optional_node_property(_${field.name})
% else:
<% assert False %>\
% endif
% endfor

    @final
    def __init__(
            self,
            token_store: base.TokenStore,
% for field in fields:
            ${field.name}: ${field.private_type},
% endfor
    ):
        super().__init__(token_store)
% for field in fields:
        self._${field.name} = ${field.name}
% endfor

    @property
    def first_token(self) -> base.RawTokenModel:
        return self._${fields[0].name}.first_token

    @property
    def last_token(self) -> base.RawTokenModel:
        return self._${fields[-1].name}.last_token

    def clone(self: _Self, token_store: base.TokenStore, token_transformer: base.TokenTransformer) -> _Self:
        return type(self)(
            token_store,
% for field in fields:
            self._${field.name}.clone(token_store, token_transformer),
% endfor
        )
    
    def _reattach(self, token_store: base.TokenStore, token_transformer: base.TokenTransformer) -> None:
        self._token_store = token_store
% for field in fields:
        self._${field.name} = self._${field.name}.reattach(token_store, token_transformer)
% endfor

    def _eq(self, other: base.RawTreeModel) -> bool:
        return (
            isinstance(other, ${model_name})
% for field in fields:
            and self._${field.name} == other._${field.name}
% endfor
        )

    @classmethod
    def from_children(
            cls: Type[_Self],
% for field in fields:
<% if not field.is_public: continue %>\
            ${field.name}: ${field.public_type},
% endfor
    ) -> _Self:
% for field in fields:
% if not field.is_public:
        ${field.name} = ${field.inner_type}.from_default()
% elif field.cardinality == FieldCardinality.OPTIONAL:
<%
# mypy isn't good at inferring union type
type_fix = f'[{field.type_alias}]' if field.type_alias is not None else ''
%>\
        maybe_${field.name} = internal.Maybe${field.floating.name[0]}${type_fix}.from_children(${field.name}, separators=cls._${field.name}.separators)
% endif
% endfor
<%
skip_space = True
args = []
%>\
        tokens = [
% for field in fields:
% if not skip_space and field.floating != Floating.LEFT:
            Whitespace.from_default(),
% endif
% if field.cardinality == FieldCardinality.REQUIRED:
            *${field.name}.detach(),
<%
skip_space = False
args.append(field.name)
%>\
% elif field.cardinality == FieldCardinality.OPTIONAL:
            *maybe_${field.name}.detach(),
<%
skip_space = field.floating == Floating.RIGHT
args.append(f'maybe_{field.name}')
%>\
% else:
<% assert False %>\
% endif
% endfor
        ]
        token_store = base.TokenStore.from_tokens(tokens)
% for arg in args:
        ${arg}.reattach(token_store)
% endfor
        return cls(token_store, ${', '.join(args)})
